<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Design and Analysis of Algorithms</title>
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">
	

    <!-- Wrapper -->
    <div id="wrapper">

        <!-- Header -->
        <header id="header">
            <div class="content">
                <div class="inner">
                    <h1><strong>Design and Analysis of Algorithms</strong></h1>
                    <p><strong>Course code: 24ECSC205<br>
                        Credits: 04<br>
                        Course instructor: Arundati Aralimatti <br>
                        Course coordiantor: Prakash Hegade<BR></strong>
                    </p>
                </div>
            </div>
            <nav>
                <ul>
                    <li><a href="#COURSE_INTRODUCTION"><strong>Course Introduction</strong></a></li>
                    <li><a href="#COURSE_PROJECT"><strong>Course Project</strong></a></li>
                    <li><a href="#COURSE_LEARNING_REFLECTIONS"><strong>Course Learning Reflections</strong></a></li>
                    <li><a href="#TEAM"><strong>ABOUT ME</strong></a></li>

                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <div id="main">

            <!-- Course Introduction -->
            <article id="COURSE_INTRODUCTION">
                <h2 class="major">Course <br>Introduction</h2>
                <span class="image main"><img src="images/ai image.jpg" alt="" /></span>
                <h3>ABOUT THE COURSE</h3>
				<p>The Design Analysis and Algorithms course focuses on applying fundamental mathematical concepts such as set theory, logic, functions, and relations, along with discrete mathematical structures like graphs, trees, and counting principles. Key topics include the use of summations, series, and recurrence relations to analyze algorithmic efficiency.</p>
                <p>The course emphasizes the integration of programming concepts, appropriate data structures, and programming paradigms to solve complex problems. Students will identify relevant knowledge applicable to given problems, explore various design alternatives, and develop optimized design solutions.</p>
                <h3>DATA STRUCTURES AND ALGORITHMS STUDIED</h3>
				<p><strong>Data Structures:</strong> Arrays, Linked List, Recursion, Binary Search Tree (BST), AVL Trees, 2-3 Trees, Heap, Red-Black Trees, Tries, Skip List, Segment Trees, Sparse Table, Fenwick Tree.</p>
                <p><strong>Graph Algorithms:</strong> Depth First Search (DFS), Breadth First Search (BFS).</p>
                <p><strong>Sorting Algorithms:</strong> Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort.</p>
                <p><strong>String Matching Algorithms:</strong> Rabin-Karp Algorithm, Boyer-Moore Algorithm, Knuth-Morris-Pratt (KMP) Algorithm.</p>
                <p><strong>Greedy Algorithms:</strong> Dijkstra's Algorithm, Kruskal's Algorithm, Prim's Algorithm.</p>
                <p><strong>Dynamic Programming Algorithms:</strong> Floyd-Warshall Algorithm, Bellman-Ford Algorithm.</p>
                <p><strong>Other Problems:</strong> Traveling Salesman Problem, Huffman Algorithm, Knapsack Problem.</p>
                <h3>TEXTBOOK AUTHORS</h3>
                <P> 1.ThomasH.Cormen,CharlesE.Leiserson,RonaldL.Rivest,andCliffordStein, Introductionto
                    Algorithms,FourthEdition,TheMITPress,2022.<br>
                    2. AnanyV. Levitin, Introduction to theDesignandAnalysisof Algorithms. Addison-Wesley
                    LongmanPublishingCo,2012 </P>
				<h3>REAL TIME APPLICATION OF THE COURSE</h3>
				<p>The <strong>Design Analysis and Algorithms (DAA)</strong> course connects to real-time applications by providing mathematical and algorithmic tools for solving complex problems. Concepts like <strong>set theory</strong>, <strong>logic</strong>, and <strong>graphs</strong> are crucial in fields such as <strong>database design</strong>, <strong>AI</strong>, and <strong>network communication</strong> (e.g., routing protocols and GPS). <strong>Recurrence relations</strong> and <strong>series</strong> help analyze algorithm efficiency, essential for real-time systems (e.g., <strong>merge sort</strong> in search engines). <strong>Data structures</strong> like <strong>hash tables</strong> and <strong>trees</strong> are foundational in <strong>cloud computing</strong> and <strong>big data analytics</strong>. The course bridges theory and practice, enabling the development of efficient, scalable solutions for real-time applications.</p>

				  
            </article>

            <!-- Course Project -->
            <article id="COURSE_PROJECT">
				

                <h2 class="major">Course Project</h2>
                <span class="image main"><img src="images/agri.jpg" alt="" /></span>
				<h3>Agriculture: The Backbone of Our City’s Economy</h3>
    <p>
        Agriculture is vital to our city’s economy, employing nearly 50% of the population and ensuring food security. To support this, one-fourth of the city's land is dedicated to agriculture, promoting efficient cultivation to meet urban needs. We aim to tackle key challenges such as optimizing resource use (water, fertilizers), enhancing market access, reducing supply chain inefficiencies, and integrating technology like precision farming. Addressing these areas will boost productivity, improve livelihoods, and contribute to global issues such as food security and sustainability. By investing in agriculture, we create a thriving ecosystem benefiting both rural and urban communities.
    </p>
	             
                 <h1>DREAMSCAPES</h1>
                 <h3>CITY DESIGN</h3>
				 <span class="image main"><img src="images/city.jpg" alt="" /></span>
				 <p>PROBLEM STATEMENT :Strategic approach to agricultural management</p>
                 <h3>Agricultural Management Project Functionalities</h3>
                 <p>Crop Management<br>
                    Resource Allocation<br>
                    Supply Chain Optimization<br>
                    Market Analysis<br>
                    Risk Management<br>
                    Sustainability and Compliance<br>
                    Financial Management<br>
                    Technology Integration</p>
                <h3> Team details</h3>
                <span class="image main"><img src="images/group.jpg" alt="" /></span>
                <a href="https://afrah-mohammad.github.io/Portfolio.github.io/">Afrah's portfolio </a><br>
                <a href="https://bhavanasherekar.github.io/portfolio2.github.io/">Bhavana's portfolio </a><br>
                <a href="https://srishti30092004.github.io/DAA.github.io/">Srishti's portfolio</a><br>
                


				<h4>AFRAH MOHAMMAD</h4>
                <p>USN:01FE23BCS200</p>
                <span class="image fit"><img src="images/afrah.jpg" alt="" /></span><br>
				<p class="left-align">Business Case : Excessive Wastage of Water During Irrigation<br>
                    Description: Unequal amount of water is going to all the fields, causing some crops to receive more water and others less, which hampers production.<br>
                    Probable Tools: Segment Trees or Fenwick Trees<br><br>
                    <pre><code>
void update(int x, int delta)

{

for(  ; x <= n; x += x&-x)

BIT[x] += delta;

}
                    </code></pre>
                    Business Case : Unorganized Distribution of Harvested Products<br>
                    Description: After crops are produced and sent to the city for sale, some areas of the city receive more crops while others receive less, leading to an imbalance in meeting demand in different regions.<br>
                    Probable Tools: Heap, Dijkstra's Algorithm<br>
                    <pre><code>
    HeapBottomUp(H[1..n])
    for k = floor(n / 2) downto 1 do
        v = H[k]
        heap = false

        while not heap and 2 * k <= n do
            j = 2 * k
            if j < n and H[j] < H[j + 1] then
                j = j + 1
            if v >= H[j] then
                heap = true
            else
                H[k] = H[j]
                k = j
        H[k] = v

                    </code></pre>
                    
				</p>
                <h4>BHAVANA P SHEREKAR</h4>
                <p>USN:01FE23BCS214</p>
				<span class="image fit"><img src="images/bhav.jpg" alt="" /></span><br>
				<p class="left-align">Business Case : Excessive Use of Pesticides and Insecticides<br>
                    Description: Unwanted amount of pesticides and insecticides are being used on crops, which alter the quality of food and increase the risk of diseases.<br>
                    Probable Tools: Sparse Tables<br><br>
                    <pre><code>
                        void buildSparseTable(int arr[], int n) {
                            // Initialize intervals of length 1
                            for (int i = 0; i < n; i++) {
                                st[i][0] = arr[i];
                            }
                        
                            // Fill the Sparse Table for larger intervals
                            for (int j = 1; (1 << j) <= n; j++) { // j is log(interval size)
                                for (int i = 0; i + (1 << j) - 1 < n; i++) { // Ensure within bounds
                                    st[i][j] = (st[i][j - 1] < st[i + (1 << (j - 1))][j - 1]) 
                                                ? st[i][j - 1] 
                                                : st[i + (1 << (j - 1))][j - 1];
                                }
                            }
                        }
                        
                        // Function to perform RMQ using the Sparse Table
                        int rangeMinQuery(int L, int R) {
                            int j = (int)log2(R - L + 1); // Largest power of 2 within the range
                            return (st[L][j] < st[R - (1 << j) + 1][j]) 
                                    ? st[L][j] 
                                    : st[R - (1 << j) + 1][j];
                        }
                    

                    

                    </code></pre>
                    
                    Business Case : Transportation in Agricultural Area<br>
                    Description: No proper system for transportation in the field, and the interconnection of fields is unjustified.<br>
                    Probable Tools: Kruskal's or Prim's Algorithm
                    <pre><code>
    ALGORITHM Kruskal(G)
    sort E in nondecreasing order of the edge weights w(e₁₁) <= ... <= w(ei|E|)
    ET = Ø
    ecounter = 0

    while ecounter < |V| - 1 do
        k = k + 1
        if ET ∪ {eₖ} is acyclic
            ET = ET ∪ {eₖ}
            ecounter = ecounter + 1

    return ET

                    </code></pre>
                  <br>
                  <pre><code>
                    ALGORITHM Prim(G)
    VT = {V₀}
    ET = Ø

    for i = 1 to |V| - 1 do
        find a minimum weight edge e* = (v*, u*) along all the edges (v, u) such that v ∈ VT and u ∉ VT
        VT = VT ∪ {u*}
        ET = ET ∪ {e*}

    return ET

                  </code></pre>

                
				</p>
                <h4>SRISHTI MANVI</h4>
                <p>USN:01FE23BCS045</p>
				<span class="image fit"><img src="images/srish.jpg" alt="" /></span><BR>  
				<p class="left-align">Business Case: No proper disposal of weeds<br>
                    Description: Due to no proper disposal of weeds, they tend to grow again causing damage and more work for removal.<br>
                    Probable Tools: Hashing, Traveling Salesman Problem (TSP) or Prim's Algorithm<br><br>
                    <pre><code>
                        // Hash function to compute the index
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Function to insert a key-value pair into the hash table
void insert(int key, int value) {
    int index = hashFunction(key);

    // Linear probing in case of collision
    while (hashTable[index].isOccupied) {
        if (hashTable[index].key == key) {
            // Update the value if the key already exists
            hashTable[index].value = value;
            return;
        }
        index = (index + 1) % TABLE_SIZE; // Move to the next slot
    }

    // Insert the new key-value pair
    hashTable[index].key = key;
    hashTable[index].value = value;
    hashTable[index].isOccupied = 1;
}

// Function to search for a key in the hash table
int search(int key) {
    int index = hashFunction(key);

    // Linear probing to search for the key
    while (hashTable[index].isOccupied) {
        if (hashTable[index].key == key) {
            return hashTable[index].value; // Key found
        }
        index = (index + 1) % TABLE_SIZE; // Move to the next slot
    }

    return -1; // Key not found
}

                    </code></pre>
<br>
<pre><code>
    ALGORITHM Prim(G)
VT = {V₀}
ET = Ø

for i = 1 to |V| - 1 do
find a minimum weight edge e* = (v*, u*) along all the edges (v, u) such that v ∈ VT and u ∉ VT
VT = VT ∪ {u*}
ET = ET ∪ {e*}

return ET

  </code></pre>
                    
                    Business Case: Unorganized distribution of harvested products<br>
                    Description: When the crops are produced and further sent to the city for sale, some parts of the city receive more amount of crops and some less, in which demand of that area is not satisfied.<br>
                    Probable Tools: Heap, Dijkstra's Algorithm

                    <pre><code>
                        HeapBottomUp(H[1..n])
                        for k = floor(n / 2) downto 1 do
                            v = H[k]
                            heap = false
                    
                            while not heap and 2 * k <= n do
                                j = 2 * k
                                if j < n and H[j] < H[j + 1] then
                                    j = j + 1
                                if v >= H[j] then
                                    heap = true
                                else
                                    H[k] = H[j]
                                    k = j
                            H[k] = v
                    
                                        </code></pre>
                                        <br>
                                        <pre><code>
     ALGORITHM Dijkstra(G, s)
    Initialize(Q)
    
    for every vertex v in V do
        pv = null
        Insert(Q, v, dv)

    ds = 0
    Decrease(Q, s, ds)
    VT = Ø

    for i = 1 to |V| - 1 do
        u* = DeleteMin(Q)
        VT = VT ∪ {u*}

        for every vertex u in V - VT that is adjacent to u* do
            if du* + w(u*, u) < du then
                du = du* + w(u*, u)
                pu = u*
                Decrease(Q, u, du)

                                        </code></pre>
				</p>
                <h4>SUSHMITA SHANBHAG</h4>
                <p>USN:01FE23BCS199</p>
				<span class="image fit"><img src="images/sush.jpg" alt="" /></span><br>
                <p class="left-align">Business Case: Mixing fields of different crops<br>
                    Description: Same type of crops are being grown on different lands far away which creates problem during harvest.<br>
                    Probable Tools: Graph (BFS/DFS), Dijkstra's Algorithm<br><br>
                    
                    Business Case: Transportation in agricultural area<br>
                    Description: No proper system for transportation in field and as to which fields should be interconnected to which, is unjustified.<br>
                    Probable Tools: Kruskal's or Prim's Algorithm
				</p>
				</article>

            <!-- Course Learning Reflections -->
            <article id="COURSE_LEARNING_REFLECTIONS">
                <h2 class="major">Course Learning <br>Reflections</h2>				<p>In nature, problems can be solved through repetition, like when we repeat steps in a process (iteration). Some problems can be broken into smaller, similar parts, like how a tree grows branches (recursion). Other problems require trying out different possibilities until the right solution is found, like solving a puzzle or finding your way out of a maze (backtracking).</p>

<p>Space and time efficiency are about using resources wisely. Space efficiency means using less memory so that we can handle bigger tasks on computers without running out of storage. Time efficiency means completing tasks faster, which is very important when dealing with urgent or large-scale problems. Both are important because they make systems work smoothly and save valuable resources.</p>

<p>From Chapter 2, one big takeaway is that solving big problems is easier if we divide them into smaller, more manageable parts. Reusing solutions for parts of the problem we've already solved also saves time. Additionally, some problems can be solved by making quick, smart decisions at each step without looking back too much.</p>

<p>Trees are very useful for organizing and solving problems in a structured way. A Binary Search Tree (BST) helps us find or store things quickly. AVL trees and Red-Black trees keep things balanced, which ensures that they remain efficient even when we’re working with large amounts of data. Heaps are great for finding the biggest or smallest items quickly, while Tries are useful for searching things like words or prefixes in a dictionary.</p>

<p>Arrays are one of the simplest ways to store lots of data, but we need algorithms to search, sort, or update them efficiently. These algorithms help in real-life situations, like filtering results in a search engine or organizing items in an e-commerce store.</p>

<p>Trees and graphs are both ways to organize data, but they are different. Trees have a clear hierarchy, like a family tree, and are used for things like organizing files. Graphs, on the other hand, are more like city maps, where multiple paths connect different points. Traversing a tree or graph means visiting all its parts, which is useful for searching or analyzing data.</p>

<p>Sorting and searching algorithms are everywhere in real life. Sorting helps arrange things in order, like ranking students by their scores or organizing books alphabetically. Searching is about quickly finding what you need, like locating a specific product in a store.</p>

<p>Graph algorithms like spanning trees and shortest paths are very important. Spanning trees help create efficient networks, like minimizing the amount of cable needed to connect electricity to homes. Shortest path algorithms are used in everyday life, like finding the quickest route on Google Maps or optimizing delivery routes for packages.</p>

<p>Finally, different algorithm design techniques help solve problems effectively. Breaking problems into smaller pieces makes them easier to handle. Reusing solutions avoids unnecessary work. Making step-by-step decisions helps solve problems quickly, while exploring all possibilities can help find the best solution when the situation is more complex.</p>

            </article>

            <!-- TEAM-->
            <article id="TEAM">
                <h2 class="major">ABOUT ME</h2>
                <span class="image main"><img src="images/sush.jpg" alt="" /></span>
                <p>Hi, I'm Sushmita Shanbhag, a B.Tech student specializing in Computer Science and Engineering at KLE Tech University. I am passionate about technology and problem-solving, with proficiency in programming languages such as C, C++, Python, HTML, and SQL.<br>

                    Beyond academics, I enjoy pursuing my hobbies, which include listening to music, painting, gardening, and watching movies. These activities allow me to stay creative, balanced, and connected to my interests outside the technical realm</p>
				<h3>ASSIGNED BUSINESS CASES :</h3><br>
				  <h4> Mixing fields of different crops</h4>
					
					<P>Description:<br>
						* The same type of crops are cultivated on different, geographically distant lands.<br>
						* This creates challenges during the harvesting process.</P>
					<p>Potential Solutions/Tools:<br>
					 * Graph (BFS/DFS)<br>
                     <pre><code>
                        void DFS(int m[10][10], int v, int source) {
                            visited[source] = 1;
                            cout << source << "\t";
                            for (int i = 0; i < v; i++) {
                                if (m[source][i] == 1 && visited[i] == 0) {
                                    DFS(m, v, i);
                                }
                            }
                        }
                        
                        int main() {
                            int source;
                            for (int i = 0; i < v; i++) {
                                visited[i] = 0;
                            }
                        
                            cout << "Enter the source vertex: ";
                            cin >> source;
                        
                            cout << "The DFS Traversal is... \n";
                            DFS(m, v, source);
                        
                            return 0;
                        }
                        
                     </code></pre>
<br>
<pre><code>
    #include <iostream>
        using namespace std;
        
        void bfs(int m[10][10], int v, int source) {
            int queue[20];
            int front = 0, rear = 0, u, i;
            int visited[10];
        
            for (i = 0; i < v; i++)
                visited[i] = 0;
        
            queue[rear] = source;
            visited[source] = 1;
        
            cout << "The BFS Traversal is... \n";
        
            while (front <= rear) {
                u = queue[front];
                cout << u << "\t";
                front++;
        
                for (i = 0; i < v; i++) {
                    if (m[u][i] == 1 && visited[i] == 0) {
                        visited[i] = 1;
                        rear++;
                        queue[rear] = i;
                    }
                }
            }
        }
        
        int main() {
            int m[10][10] = {{0, 1, 1, 0, 0}, {1, 0, 0, 1, 1},
                             {1, 0, 0, 0, 1}, {0, 1, 0, 0, 0}, {0, 1, 1, 0, 0}};
            int v = 5;  // Number of vertices
            int source;
        
            cout << "Enter the source vertex: ";
            cin >> source;
        
            bfs(m, v, source);
        
            return 0;
        }
        
</code></pre>
					 * Dijkstra's Algorithm</p>
                     
                     <pre><code>
                        ALGORITHM Dijkstra(G, s)
                       Initialize(Q)
                       
                       for every vertex v in V do
                           pv = null
                           Insert(Q, v, dv)
                   
                       ds = 0
                       Decrease(Q, s, ds)
                       VT = Ø
                   
                       for i = 1 to |V| - 1 do
                           u* = DeleteMin(Q)
                           VT = VT ∪ {u*}
                   
                           for every vertex u in V - VT that is adjacent to u* do
                               if du* + w(u*, u) < du then
                                   du = du* + w(u*, u)
                                   pu = u*
                                   Decrease(Q, u, du)
                   
                                                           </code></pre>
					 <p>Sustainable Development goals that can be used:<br>
						* SDG 2: Zero Hunger <br>
						* SDG 12: Responsible Consumption and Production<br>
                        *SDG 11: Sustainable Cities and Communities</p>
				
						<h4>Transportation in agricultural area</h4> 
						<p>Description<br>
							* The current transportation system within the agricultural area is inefficient and inadequate.<br>
							* There's a lack of clarity regarding which fields should be connected by roads or other transportation infrastructure.</p>
						<p>Potential Solutions/Tools:<br>
							* Kruskal's Algorithm<br>
                            <pre><code>
                                ALGORITHM Kruskal(G)
                                sort E in nondecreasing order of the edge weights w(e₁₁) <= ... <= w(ei|E|)
                                ET = Ø
                                ecounter = 0
                            
                                while ecounter < |V| - 1 do
                                    k = k + 1
                                    if ET ∪ {eₖ} is acyclic
                                        ET = ET ∪ {eₖ}
                                        ecounter = ecounter + 1
                            
                                return ET
                            
                                                </code></pre>
							* Prim's Algorithm</p>
                            <pre><code>
                                ALGORITHM Prim(G)
                VT = {V₀}
                ET = Ø
            
                for i = 1 to |V| - 1 do
                    find a minimum weight edge e* = (v*, u*) along all the edges (v, u) such that v ∈ VT and u ∉ VT
                    VT = VT ∪ {u*}
                    ET = ET ∪ {e*}
            
                return ET
            
                              </code></pre>
							<p>Sustainable Development goals that can be used:<br>
								*SDG 9: Industry, Innovation, and Infrastructure<br>
								* SDG 2: Zero Hunger<br>
								*SDG 13: Climate Action<br>
								*SDG 11: Sustainable Cities and Communities</p>
				       <h2>project implementation</h2>
				       <pre><code>
#include <iostream>
#include <limits>
#include <iomanip>

using namespace std;

#define MAX_FIELDS 100
#define MAX_CONNECTIONS 100

typedef pair<string, double> Edge; 

void addEdge(string fields[], double distances[MAX_FIELDS][MAX_FIELDS], int u, int v, double weight) {
    distances[u][v] = weight;
    distances[v][u] = weight;
}

void findClusters(int n, string fields[], double distances[MAX_FIELDS][MAX_FIELDS], bool visited[], int clusters[MAX_FIELDS]) {
    int clusterId = 0;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            clusters[i] = clusterId;
            visited[i] = true;

            for (int j = 0; j < n; j++) {
                if (distances[i][j] > 0 && !visited[j]) {  
                    visited[j] = true;
                    clusters[j] = clusterId;
                }
            }

            clusterId++;
        }
    }
}

void dijkstra(int n, double distances[MAX_FIELDS][MAX_FIELDS], int start, string fields[]) {
    double dist[MAX_FIELDS];
    bool visited[MAX_FIELDS] = {false};

    for (int i = 0; i < n; i++) {
        dist[i] = numeric_limits<double>::infinity();
    }
    dist[start] = 0;

    for (int i = 0; i < n; i++) {
        int u = -1;
        double minDist = numeric_limits<double>::infinity();

        for (int j = 0; j < n; j++) {
            if (!visited[j] && dist[j] < minDist) {
                minDist = dist[j];
                u = j;
            }
        }

        if (u == -1) break;
        visited[u] = true;

        for (int v = 0; v < n; v++) {
            if (distances[u][v] > 0) {
                double newDist = dist[u] + distances[u][v];
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                }
            }
        }
    }

    cout << "\nShortest paths from " << fields[start] << ":" << endl;
    for (int i = 0; i < n; i++) {
        if (dist[i] == numeric_limits<double>::infinity()) {
            cout << "  To " << fields[i] << ": No direct path." << endl;
        } else {
            cout << "  To " << fields[i] << ": " << fixed << setprecision(2) << dist[i] << " units" << endl;
        }
    }
    cout << endl;
}

int main() {
    string crops[] = {"Wheat", "Rice", "Corn", "Soybean", "Barley"};
    int numCrops = 5;

    cout << "Welcome to the Crop Field Network!" << endl;
    cout << "Here are the available crop types:" << endl;
    for (int i = 0; i < numCrops; ++i) {
        cout << i + 1 << ". " << crops[i] << endl;
    }

    // Input crop details
    int n;
    cout << "\nHow many fields do you have? ";
    cin >> n;

    string fields[MAX_FIELDS];
    string cropType[MAX_FIELDS]; 
    for (int i = 0; i < n; ++i) {
        cout << "\nField " << i + 1 << ":\n";
        cout << "Enter field name: ";
        cin >> fields[i];
        int cropChoice;
        cout << "Which crop does this field have? (Select a number) ";
        cin >> cropChoice;

        if (cropChoice < 1 || cropChoice > numCrops) {
            cout << "Oops, that was an invalid choice! Please try again." << endl;
            --i; // Retry the current field
            continue;
        }

        cropType[i] = crops[cropChoice - 1];
    }

    // Input distances between fields
    double distances[MAX_FIELDS][MAX_FIELDS] = {0}; 
    int edges;
    cout << "\nHow many connections between fields would you like to enter? ";
    cin >> edges;

    for (int i = 0; i < edges; ++i) {
        string u, v;
        double distance;
        cout << "\nEnter connection " << i + 1 << " details:\n";
        cout << "Field 1: ";
        cin >> u;
        cout << "Field 2: ";
        cin >> v;
        cout << "Distance (in units): ";
        cin >> distance;

        int uIndex = -1, vIndex = -1;
        for (int i = 0; i < n; ++i) {
            if (fields[i] == u) uIndex = i;
            if (fields[i] == v) vIndex = i;
        }

        if (uIndex == -1 || vIndex == -1 || cropType[uIndex] != cropType[vIndex]) {
            cout << "Can't connect these fields, they have different crops!" << endl;
            continue;
        }

        addEdge(fields, distances, uIndex, vIndex, distance);
    }

    
    bool visited[MAX_FIELDS] = {false};
    int clusters[MAX_FIELDS] = {-1};
    findClusters(n, fields, distances, visited, clusters);

    // Step 2: Display clusters in a simple way
    cout << "\nHere are the clusters of fields:" << endl;
    for (int i = 0; i < n; i++) {
        cout << fields[i] << " is in Cluster " << clusters[i] << endl;
    }

    // Step 3: Calculate shortest paths within each cluster
    for (int i = 0; i < n; i++) {
        dijkstra(n, distances, i, fields); 
    }

    cout << "Thank you for using the Crop Field Network!" << endl;

    return 0;
}

				       </code></pre>
			</article>

        </div>

        <!-- Footer -->
        <footer id="footer">
            <p class="copyright">&copy; Design and Analysis of Algorithms. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
        </footer>

    </div>

    <!-- BG -->
    <div id="bg"></div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>

</body>
</html>
